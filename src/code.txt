static char *readFile(const char *filename)
{
    FILE *fp = fopen(filename, "r");
    fseek(fp, 0, SEEK_END);
    long file_length = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    char *contents = new char[file_length + 1];

    for (int i = 0; i < file_length + 1; i++) {
        contents[i] = 0;
    }
    fread(contents, 1, file_length, fp);
    contents[file_length + 1] = '\0';
    fclose(fp);
    return contents;
}

bool compiledStatus(GLint shaderID)
{
    GLint compiled = 0;
    glGetShaderiv(shaderID, GL_COMPILE_STATUS, &compiled);
    if (compiled) {
        return true;

    } else {
        GLint logLength;
        glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, &logLength);
        char *msgBuffer = new char[logLength];
        glGetShaderInfoLog(shaderID, logLength, NULL, msgBuffer);
        printf("%s\n", msgBuffer);
        delete (msgBuffer);
        return false;
    }
}

GLuint makeVertexShader(const char *shaderSource)
{
    GLuint vertexShaderID = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShaderID, 1, (const GLchar **) &shaderSource, NULL);
    glCompileShader(vertexShaderID);
    bool compileCorrectyl = compiledStatus(vertexShaderID);
    if (compileCorrectyl) {
        return vertexShaderID;
    }
    return -1;
}

GLuint makeFragmentShader(const char *shaderSource)
{
    GLuint fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShaderID, 1, (const GLchar **) &shaderSource, NULL);
    glCompileShader(fragmentShaderID);
    bool compileCorrectyl = compiledStatus(fragmentShaderID);
    if (compileCorrectyl) {
        return fragmentShaderID;
    }
    return -1;
}

GLuint makeShaderProgram(GLuint vertexShaderID, GLuint fragmentShaderID)
{
    GLuint shaderID = glCreateProgram();
    glAttachShader(shaderID, vertexShaderID);
    glAttachShader(shaderID, fragmentShaderID);
    glLinkProgram(shaderID);
    return shaderID;
}